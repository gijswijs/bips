<pre>
 BIP: ???
  Layer: Applications
  Title: Taro Asset Script v1
  Author: Olaoluwa Osuntokun <laolu32@gmail.com>
  Comments-Summary: No comments yet.
  Comments-URI: https://git
  Status: Draft
  Type: Standards Track
  Created: 2021-12-10
  License: BSD-2-Clause
</pre>

==Abstract==

This document describes the virtual machine execution environment used to
validate Taro transfers that utilize an </code>asset_script_version</code> of
1. The execution environment described in this document is a slight twist on
the taproot validation rules defined in BIPs 341 and 342. Given a Taro asset
one or more Taro asset leaves to be spent (inputs) and asset leaves to be
created, a "virtual" taproot Bitcoin transaction is created. This transaction
is a 1-input-1-output transaction that commits to the inputs and output set
using a merkle sum tree. With this mapping complete, validation takes place as
normal.

==Copyright==

This document is licensed under the 2-clause BSD license.

==Motivation==

The Taro asset overlay permits the usage of a nearly arbitrary virtual machine
for validation of transfers within the system. In order to reduce the scope of
the initial version of the protocol, we describe a way to leverage the existing
Bitcoin Script virtual machine, allowing us to inherit a baseline set of
expressibility, while allowing implementers re-use existing tools and
libraries.

==Design==

The Taro <code>asset_script_version</code> 1 maps a Taro input and output set
to a "virtual" Bitcoin transaction. The input and output sets are committed to
within a single 1-input-1-output transaction using a normal merkle sum tree
(TODO(roasbeef): non-inclusion useful at all here??). Via the merkle-sum
invariant of the augmented merkle tree, a validator is able to enforce
non-inflation of assets by asserting that the committed input sum is ''equal''
to the committed output sum. Once this invariant is verified, execution resumes
as normal using the BIP 341+342 validation rules, with additional pre-execution
checks that may fail validation early.

===Specification===

A single 1-input-1-output transaction is used to compress the Taro state
transition state into a constant size transaction. Given a Taro asset
commitment (which lives in a taproot output), and its valid opening, the set
the previous asset ID are compressed into a single input, and the present
<code>split_commitment</code> is used to compress the output state.

====Mapping Inputs====

Given a set of inputs, each identified by a <code>prev_asset_id</code>, the
input commitment (which is used as the previous output) is constructed as
follows:

# Initialize a new empty MS-SMT tree as specified in [[../master/bip-taro-ms-smt.mediawiki|bip-taro-ms-smt]].
# If the Taro output to be validated only specifies a <code>split_commitment</code>, then the <code>prev_asset_witnesses</code> of the referenced root output are used in place.
# For each Taro input ''c_i'', identified in the <code>prev_asset_witnesses</code> field:
## Serialize the referenced previous asset leaf (identified by <code>prev_outpoint || asset_id || asset_script_hash</code>) in TLV format.
## Insert this leaf into the MS-SMT tree, with a key of the <code>prev_id_identifier</code>, a value of the serialized leaf, and sum value of the asset amount contained in the leaf.
# Obtain the root hash <code>input_root</code> and sum value <code>input_asset_sum</code> resulting from the tree creation and root digest computation.
# Let the hash of the serialized 36-byte MS-SMT root be the sole previous output of the virtual execution transaction.
# A value of zero is used for the output index of the virtual execution transaction.

With the above routine, we map the input set into a MS-SMT tree, which also
commits to the total amount being spent of any given asset. During
verification, as there may be multiple input witnesses, during validation, the
<code>asset_witness</code> for each input is used as the initial witness stack.

(TODO(roasbeef): need to map the squence number as well?)

====Mapping Outputs====

Given a Taro output, and any associated outputs contained within its
<code>split_commitment_root</code>, the output commitment is constructed as
follows:

# If the Taro output to be validated includes a
# Let the output value be the sum of all the <code>amt</code> fields on the top level as well as the split commitment cohort set, in other words the last 4-bytes of the <code>split_commitment_root</code>.
# Let the output script be the first 32-bytes of the <code>split_commitment_root</code> value converted to a segwit v1 witness program (taproot).

====Validating a State Transition====

Once the set of inputs and outputs have been mapped to our virtual Bitcoin
transaction (creating a v2 Bitcoin transaction with a single input and output),
validation proceeds as normal according to BIP 341+342 with the following
modifications:

# If the <code>input_asset_sum</code> is not exactly equal to the <code>output_asset_sum</code> validation MUST fail.
# If the Taro output to be validated only specifies a <code>split_commitment_root</code> and no explicit inputs, then a valid inclusion proof for the output MUST be presented and valid.
# The previous public key script for each input is to be the <code>asset_script_hash</code> for each previous input, mapped to a v1 segwit witness program (taproot).
# The input value for each included input is to be the <code>amt</code> field of the previous Taro output being spent.
# All signatures included in the witness MUST be exactly 64-bytes in length, which triggers <code>SIGHASH_DEFAULT</code> evaluation.
# If the <code>prev_asset_id</code> is blank, then ALL witnesses MUST be blank as well and the <code>prev_outpoint</code> values as well. In this case, verification succeeds as this is only a creation/minting transaction.
# If the <code>asset_id</code> value is NOT the same for each Taro input and output, validation MUST fail.
## Alternatively, if each input and output has the same referenced <code>asset_family_key</code>, then only the <code>asset_tags</code> MUST match.

(TODO(roasbeef): lift the sighash requirement here? useful for swappy stuff??)

(TODO(roasbeef): split commitment root as another control block??)

==Test Vectors==

TBD

==Backwards Compatibility==

==Reference Implementation==

github.com/lightninglabs/taro
